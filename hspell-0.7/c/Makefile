CFLAGS=-O $(EXTRACFLAGS)

PERL=perl

#all: test.wgz.sizes
all: hebrew.wgz.sizes prefixes.c

install: all

libhspell.a: dict_radix.o gimatria.o corlist.o libhspell.o $(EXTRAOBJECTS)
	-rm -f $@
	ar cr $@ $^
	-ranlib $@

hspell: hspell.o tclHash.o libhspell.a
	cc -o hspell hspell.o tclHash.o libhspell.a

# TODO: update this dependency list:
hspell.o dict_radix.o: dict_radix.h
hspell.o: prefixes.c hash.h tclHash.h
tclHash.o: tclHash.c tclHash.h
corlist.o gimatria.o hspell.o libhspell.o: hspell.h
linginfo.o: dmask.c

prefixes.c: genprefixes.pl
	$(PERL) -w ./genprefixes.pl >prefixes.c

find_sizes: find_sizes.o dict_radix.o
	$(CC) $(LDFLAGS) -o find_sizes find_sizes.o dict_radix.o

GZDICTS= dout.nouns.wolig.gz dout.verbs.gz dout.nouns.shemp.gz
DICTS=../milot ../extrawords ../biza-verbs ../biza-nouns


# hebrew.wgz contains all the words without any prefix hints like B,L,+ we
#   previously had. 
# hebrew.wgz.prefixes is the prefix hints (one byte per word, compressed).
# hebrew.wgz.sizes contains the memory sizes that reading hebrew.wgz will
#   require (this makes it easier for hspell to preallocate the needed sizes).
hebrew.wgz hebrew.wgz.prefixes: pmerge $(DICTS) $(GZDICTS)
	(gzip -dc $(GZDICTS); cat $(DICTS)) | ./pmerge -p hebrew.wgz.tmp | ../wzip | gzip -9 > hebrew.wgz
	-rm -f hebrew.wgz.prefixes
	gzip -9 < hebrew.wgz.tmp >hebrew.wgz.prefixes
	-rm -f hebrew.wgz.tmp
hebrew.wgz.sizes: hebrew.wgz find_sizes
	gzip -dc hebrew.wgz | ./find_sizes >hebrew.wgz.sizes

###################################### optional linginfo stuff ##############
# See comment on linginfo in ../Makefile.
EXTRAOBJECTS=

dolinginfo: linginfo_data hspell

# hebrew.wgz contains all the words without any prefix hints like B,L,+ we
#   previously had. 
# hebrew.wgz.prefixes is the prefix hints (one byte per word, compressed).
# hebrew.wgz.sizes contains the memory sizes that reading hebrew.wgz will
#   require (this makes it easier for hspell to preallocate the needed sizes).
# dmask.c contains an array of all possible values of the description bitmask.
#   It is generated by pack-desc.pl. This array is not too long (no more than
#   300 for the default dictionary).
#
# In the following long rule, the complete list of all words with linguistic
# details is concatanated and sent to binarize-desc.pl, which converts the
# detail information of each word into bitmap (called dmask), produces a
# spesifier that tell which prefixes are accepted with the word, and writes its
# stem. Then the words list is sorted, packed (a-la uniq), and the output files
# are written.
#
# NOTE/TODO:
# The "linginfo_data:" target line below is ugly and un-make-like. Not only
# that, it doesn't know when it's necessary to build the files again, and
# when it is not. The better make targets (hebrew.wgz et al. and
# hebrew.wgz.sizes) are commented out because the same targets were used above
# for building the version without linginfo. When building with linginfo
# becomes the default, we should remove the following line and uncomment the
# real targets.
linginfo_data: binarize-desc.pl pack-desc.pl $(DICTS) $(GZDICTS) find_sizes
#hebrew.wgz hebrew.wgz.prefixes hebrew.wgz.desc hebrew.wgz.stems hebrew.wgz.lingsizes.tmp dmask.c: binarize-desc.pl pack-desc.pl $(DICTS) $(GZDICTS)
	(gzip -dc $(GZDICTS); cat $(DICTS)) | $(PERL) binarize-desc.pl | \
		sort -u | $(PERL) pack-desc.pl -p hebrew.wgz.prefixes.tmp \
		-d hebrew.wgz.desc.tmp -s hebrew.wgz.stems.tmp \
		-l hebrew.wgz.lingsizes.tmp | \
		../wzip | gzip -9 > hebrew.wgz

	-rm -f hebrew.wgz.prefixes
	gzip -9 < hebrew.wgz.prefixes.tmp >hebrew.wgz.prefixes
	-rm -f hebrew.wgz.prefixes.tmp
	-rm -f hebrew.wgz.desc
	gzip -9 < hebrew.wgz.desc.tmp >hebrew.wgz.desc
	-rm -f hebrew.wgz.desc.tmp
	-rm -f hebrew.wgz.stems
	gzip -9 < hebrew.wgz.stems.tmp >hebrew.wgz.stems
	-rm -f hebrew.wgz.stems.tmp
#
#hebrew.wgz.sizes: hebrew.wgz find_sizes hebrew.wgz.lingsizes.tmp
	gzip -dc hebrew.wgz | ./find_sizes >hebrew.wgz.sizes
	cat hebrew.wgz.lingsizes.tmp >> hebrew.wgz.sizes
############################################################################


# dout.* are the outputs from the various word-list generators with the
# -d option (i.e., with an explanation on how each word was derived)
#
# The dout files are quite large, as much as 10MB. To lower the amount
# of temporary space needed during compilation (is this necessary nowadays?)
#
dout.nouns.%:  ../%.dat ../wolig.pl
	$(PERL) -w ../wolig.pl -d $< > $@
dout.nouns.%.gz:  ../%.dat ../wolig.pl
	$(PERL) -w ../wolig.pl -d $< | gzip -4 > $@
dout.nouns.shemp.gz:  shemp.dat ../wolig.pl
	$(PERL) -w ../wolig.pl -d $< | gzip -4 > $@

# SEDCMD is left here as a non-user-friendly option to choose whether you want
# over a 150,000 more rare verb forms or not. The default here is not, but the
# RPM spec builds both forms (it even plays tricks and builds out.verbs only
# once without any sed and then does the sed itself).

#SEDCMD=s/\+//
SEDCMD=/\+/d

dout.verbs.gz shemp.dat: ../woo ../woo.dat
	$(PERL) -w ../woo -d ../woo.dat | sed "$(SEDCMD)" | gzip -4 > $@

clean:
	rm -f corlist.o dict_radix.o find_sizes.o gimatria.o \
	      hspell.o tclHash.o hebrew.wgz hebrew.wgz.sizes \
	      hebrew.wgz.prefixes dout.nouns.shemp.gz shemp.dat \
	      dout.nouns.wolig.gz dout.verbs.gz hspell find_sizes \
	      prefixes.c 
