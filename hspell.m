/* Copyright (C) 2003 Nadav Har'El and Dan Kenigsberg 		*/
/* Modified for HSpellService by Mitz Pettel on Fri Mar 15 2002.*/

#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>
#include <assert.h>
#include <time.h>
#include <unistd.h>
#include <string.h>

#include "dict_radix.h"
#include "gimatria.h"
#include "corlist.h"
#include "hash.h"
#import <Foundation/Foundation.h>
#import "NSString-MPAdditions.h"

#define HSPELL_VERSION "0.6"

int debug=0;

/* Load the data files */
static void
load_data(struct dict_radix **dictp)
{
	clock_t t1, t2;
	if(debug){
		fprintf(stderr,"Loading data files... ");
		t1=clock();
	}

	*dictp = new_dict_radix();
#ifndef DICTIONARY_BASE
#define DICTIONARY_BASE [[NSFileManager defaultManager] fileSystemRepresentationWithPath:[[[NSBundle mainBundle] resourcePath] stringByAppendingPathComponent:@"hebrew.wgz"]]
#endif

	if(!read_dict(*dictp, DICTIONARY_BASE)){
		fprintf(stderr,"Sorry, could not read dictionary. Hspell "
			"was probably installed improperly.\n");
		exit(1);
	}

	if(debug){
		t2=clock();
		fprintf(stderr,"done (%d ms).\n",
				(int)((t2-t1)/(CLOCKS_PER_SEC/1000)));
	}
}

/*
 * The prefix tree "prefix_tree" is built by build_prefix_tree, from a list of
 * known combinations of prefixes. Each prefix also has a mask that determines
 * to what kind of words it can be applied.
 *
 * The list of known prefixes and masks were defined in the prefixes[] and
 * masks[] arrays in prefixes.c. That file is automatically generated by the
 * genprefixes.pl program.
 */

#include "hspell-0.6/c/prefixes.c"

struct prefix_node {
	/* if a prefix has a certain 'mask', and lookup on a word returns
	 * 'val' (a bitmask of prefixes allowed for it), our prefix is
	 * allowed on this word if and only if (mask & val)!=0.
	 *
	 * This means that 'mask' defines the bits that this prefix "supplies"
	 * and he 'val' defined for a word is the bits this words insists on
	 * getting at least one of (i.e., val is the list of types of
	 * prefixes that are allowed for this word).
	 */
	int mask;
	struct prefix_node *next['ת'-'א'+1];
};
static struct prefix_node *prefix_tree = 0;

static void
build_prefix_tree(void){
	int i;
	const char *p;
	struct prefix_node **n;
	for(i=0; prefixes[i]; i++){
		p=prefixes[i];
		n=&prefix_tree;
		if(debug)
			fprintf(stderr,"prefix %s ",p);
		while(*p){
			if(!(*n))
				*n=(struct prefix_node *)
					calloc(1,sizeof(struct prefix_node));
			n=& ((*n)->next[*p-'א']);
			p++;
		}
		/* define the mask (making sure the node exists). */
		if(!*n)
			*n=(struct prefix_node *)
				calloc(1,sizeof(struct prefix_node));
		(*n)->mask=masks[i];

		if(debug)
			fprintf(stderr,"mask=%d\n",(*n)->mask);
	}
}


#define ishebrew(c) ((c)>=(int)(unsigned char)'א' && (c)<=(int)(unsigned char)'ת')
#define isUhebrew(c) ((c)>=0x05d0 && (c)<=0x05ea)

static int
check_word(struct dict_radix *dict, const char *word, int *preflen)
{
	int hashebrew;
	const char *w=word;
	struct prefix_node *n;
	*preflen = 0;

	/* ignore empty words: */
	hashebrew=0;
	while(*w){
		if(*w>='א' && *w<='ת'){
			hashebrew=1;
			break;
		}
		(*preflen)++;
		w++;
	}
	if(!hashebrew)
		return 1; /* ignore (accept) empty words */


	n=prefix_tree;
	if(debug)
		fprintf(stderr,"looking %s\n",w);
	while(*w && n){
		/* eat up the " if necessary, to recognize words like
		 * ה"שטיח".  or הידיעה ש"המידע...".
		 * See the Academy's punctuation rules (see לשוננו לעם, טבת,
		 * תשס"ב) for an explanation of this rule (we're probably don't
		 * support here everything they suggested; in particular I
		 * don't recognize a single quote as valid form of merchaot).
		 */
		if(*w=='"'){
			(*preflen)++;
			w++;
			continue;
		}
		/* The first case here is the Academia's "ha-ktiv hasar
		 * ha-niqqud" rule of doubling a consonant waw in the middle
		 * a word, unless it's already next to a waw. When adding a
		 * prefix, any initial waw in a word will nececessarily
		 * become a consonant waw in the middle of the word.
		 * The "else if" below is the normal check.
		 */
		if(n!=prefix_tree && *w=='ו' && w[-1]!='ו'){
			if(w[1]=='ו'){
				if(w[2]!='ו' && (lookup(dict,w+1) & n->mask)){
					/* for example: הוועד */
					if(debug)
						fprintf(stderr,"found %s: double waw.\n",w);
					return 1;
				} else if(lookup(dict,w) & n->mask){
					/* for example: הווים */
					if(debug)
						fprintf(stderr,"found %s: nondouble waw.\n",w);
					return 1;
				}
			}
		} else {
			if (debug) fprintf (stderr, "tried %s mask %d prefmask %d\n",w,lookup(dict,w), n->mask);
			if(lookup(dict,w) & n->mask) return 1; /* found word! */
		}

		/* try the next prefix... */
		if(*w>='א' && *w<='ת'){
			n=n->next[*w-'א'];
			(*preflen)++;
			w++;
		} else {
			break;
		}
	}
	if(n && !*w){
		/* allow prefix followed by nothing (or a non-word like
		 * number, maqaf, etc.) */
		if(debug) fprintf(stderr,"Accepting empty word\n");
		return 1;
	} else
		return 0; /* unrecognized (mis-spelled) word */
}

static struct dict_radix *dict = NULL;

/* try to find corrections for word */
NSArray *trycorrect( NSString *word )
{
        const char	*w = [word cStringWithEncoding:kCFStringEncodingISOLatinHebrew];
        NSMutableArray	*result = [NSMutableArray array];
	char buf[30];
	int i;
	int len=strlen(w), preflen;
	static char *similar[] = {"העא", "גה", "כח", "תט", "צס", "שס",
				  "כק", "בו", "פב"};

#define TRYBUF if(check_word(dict, buf, &preflen)) [result addObject:[NSString stringWithCString:buf encoding:kCFStringEncodingISOLatinHebrew]];
	/* try to add a missing em kri'a - yud or vav */
	for(i=1;i<len;i++){
		snprintf(buf,sizeof(buf),"%.*sי%s",i,w,w+i);
		TRYBUF;
		snprintf(buf,sizeof(buf),"%.*sו%s",i,w,w+i);
		TRYBUF;
	}
	/* try to remove an em kri'a - yud or vav */
	/* NOTE: in hspell.pl the loop was from i=0 to i<len... */
	for(i=1;i<len-1;i++){
		if(w[i]=='י' || w[i]=='ו'){
			snprintf(buf,sizeof(buf),"%.*s%s",i,w,w+i+1);
			TRYBUF;
		}
	}
	/* try to add or remove an aleph (is that useful?) */
	/* TODO: don't add an aleph next to yud or non-double vav,
	 * as it can't be an em kria there? */
	for(i=1;i<len;i++){
		snprintf(buf,sizeof(buf),"%.*sא%s",i,w,w+i);
		TRYBUF;
	}
	for(i=1;i<len-1;i++){
		if(w[i]=='א'){
			snprintf(buf,sizeof(buf),"%.*s%s",i,w,w+i+1);
			TRYBUF;
		}
	}
	/* try to replace similarly sounding (for certain people) letters:
	 */
	for(i=0;i<len;i++){
		int group;
		char *g;
		for(group=0; group< (sizeof(similar)/sizeof(similar[0]));
				group++){
			for(g=similar[group];*g && *g!=w[i];g++);
				;
			if(*g){
				/* character in group - try the other ones
				 * in this group! */
				for(g=similar[group];*g;g++){
					if(*g==w[i]) continue;
					if(i>0 && w[i]=='ו' && w[i+1]=='ו')
						snprintf(buf,sizeof(buf),
						    "%.*s%c%s",i,w,*g,w+i+2);
					else if(*g=='ו')
						snprintf(buf,sizeof(buf),
						    "%.*sוו%s",i,w,w+i+1);
					else
						snprintf(buf,sizeof(buf),
						   "%.*s%c%s",i,w,*g,w+i+1);
					TRYBUF;
				}
			}
		}
	}
	/* try to replace a non-final letter at the end of the word by its
	 * final form and vice versa (useful check for abbreviations) */
	strncpy(buf,w,sizeof(buf));
	switch(w[len-1]){
		case 'ך': buf[len-1]='כ'; break;
		case 'ם': buf[len-1]='מ'; break;
		case 'ן': buf[len-1]='נ'; break;
		case 'ץ': buf[len-1]='צ'; break;
		case 'ף': buf[len-1]='פ'; break;
		case 'כ': buf[len-1]='ך'; break;
		case 'מ': buf[len-1]='ם'; break;
		case 'נ': buf[len-1]='ן'; break;
		case 'צ': buf[len-1]='ץ'; break;
		case 'פ': buf[len-1]='ף'; break;
	}
	if(buf[len-1]!=w[len-1]){ TRYBUF; }
	/* try to make the word into an acronym (add " before last character */
	if(len>=2){
		snprintf(buf,sizeof(buf), "%.*s\"%c",len-1,w,w[len-1]);
		TRYBUF;
	}
	/* try to make the word into an abbreviation (add ' at the end) */
	snprintf(buf,sizeof(buf), "%s'",w);
	TRYBUF;
        return result;
}

/* used for sorting later: */
static int 
compare_key(const void *a, const void *b){
	register hspell_hash_keyvalue *aa = (hspell_hash_keyvalue *)a;
	register hspell_hash_keyvalue *bb = (hspell_hash_keyvalue *)b;
	return strcmp(aa->key, bb->key);
}
static int 
compare_value_reverse(const void *a, const void *b){
	register hspell_hash_keyvalue *aa = (hspell_hash_keyvalue *)a;
	register hspell_hash_keyvalue *bb = (hspell_hash_keyvalue *)b;
	if(aa->value < bb->value)
		return 1;
	else if(aa->value > bb->value)
		return -1;
	else return 0;
}

#define VERSION_IDENTIFICATION ("@(#) International Ispell Version 3.1.20 " \
			       "(but really Hspell/C " HSPELL_VERSION ")\n")


void initHspell()
{
    load_data(&dict);
    build_prefix_tree();
}

NSRange hspell( NSSpellServer *spellServer, NSString *stringToCheck, int *wordCount, BOOL countOnly )
{
#define MAXWORD 30
        NSRange range;
	char word[MAXWORD+1], *w;
	int offset=0;
	UniChar uc;
	int res;
        int textLength = [stringToCheck length];

        int wordOffset =0;
        int wordLength = 0;

	int preflen; /* used by -l */

        *wordCount = 0;
        range.location = 0;
        range.length = 0;

        if ( dict==NULL )
            initHspell();



	for( offset = 0; offset<=textLength; offset++ )
        {
		uc = ( offset==textLength ? 0 : [stringToCheck characterAtIndex:offset] );
                
		if(isUhebrew(uc) || uc=='\'' || uc=='"'){
			/* swallow up another letter into the word (if the word
			 * is too long, lose the last letters) */
			if((wordLength)<MAXWORD)
				word[(wordLength)++]=( uc<0x05d0 ? uc : uc-0x04f0 );
		} else if(wordLength){
                        (*wordCount)++;
			/* found word seperator, after a non-empty word */
			word[wordLength]='\0';
			(wordOffset) = offset-(wordLength);
			/* TODO: convert two single quotes ('') into one
			 * double quote ("). For TeX junkies. */
                    if ( !countOnly )
                    {
			/* remove quotes from end or beginning of the word
			 * (we do leave, however, single quotes in the middle
			 * of the word - used to signify "j" sound in Hebrew,
			 * for example, and double quotes used to signify
			 * acronyms. A single quote at the end of the word is
			 * used to signify an abbreviate - or can be an actual
			 * quote (there is no difference in ASCII...), so we
			 * must check both possibilities. */
			w=word;
			if(*w=='"' || *w=='\''){
				w++; (wordLength)--; (wordOffset)++;
			}
			if(w[(wordLength)-1]=='"'){
				w[(wordLength)-1]='\0'; (wordLength)--;
			}
			res=check_word(dict,w,&preflen);
			if(res!=1 && (res=is_canonic_gimatria(w))){
				if(debug)
					fprintf(stderr,"found canonic gimatria\n");
				res=1;
			}
			if(res!=1 && w[(wordLength)-1]=='\''){
				/* try again, without the quote */
				w[(wordLength)-1]='\0'; (wordLength)--;
				res=check_word(dict,w,&preflen);
			}

			if(res){
				if(debug)
					fprintf(stderr,"correct: %s\n",w);
			} else if (![spellServer isWordInUserDictionaries:[stringToCheck substringWithRange:NSMakeRange(wordOffset, wordLength)] caseSensitive:NO]) {
				/* Mispelling in "spell" mode: remember this
				   mispelling for later */
                                range.location = wordOffset;
                                range.length = wordLength;
				if(debug)
					fprintf(stderr,"mispelling: %s\n",w);
                                break;
			}
                    }
			/* we're done with this word: */
			(wordLength)=0;
		}
                

		}
        
	return range;
}
